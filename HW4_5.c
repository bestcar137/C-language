#include <stdio.h>

// ============================================================
// 📘 문제 요약:
// ============================================================
// 2차원 미로에서 출발점('e')부터 출구('x')까지 도달 가능한 경로를
// 스택(LIFO 구조)을 사용하여 탐색하는 프로그램입니다.
//
// 📌 조건 정리:
// - '1' = 벽, '0' = 길, 'e' = 시작점, 'x' = 출구
// - 지나간 경로는 '.'으로 표시
// - 출구에 도달하면 "success", 도달 못 하면 "fail" 출력
//
// 🔁 탐색 방식: DFS(깊이 우선 탐색) - 스택 기반
// ============================================================

// 📦 element 구조체: 미로 좌표 (행, 열)을 나타냄
typedef struct {
    short r; // 행(row)
    short c; // 열(column)
} element;

// 📦 StackType 구조체: 스택 구현
typedef struct {
    element data[10000]; // 스택 배열 (최대 10,000개 저장 가능)
    int top;             // 현재 스택의 top 위치
} StackType;

// 📌 스택 초기화 함수: top을 -1로 설정하여 비어있음을 나타냄
void init_stack(StackType *s) {
    s->top = -1;
}

// 📌 스택이 비어 있는지 확인하는 함수
int is_empty(StackType *s) {
    return (s->top == -1);
}

// 📌 스택에 요소 추가 (푸시)
void push(StackType *s, element item) {
    s->data[++(s->top)] = item;
}

// 📌 스택에서 요소 제거 (팝)
element pop(StackType *s) {
    return s->data[(s->top)--];
}

int n;                 // 미로의 크기 (n x n)
char maze[100][100];   // 실제 미로를 저장할 2차원 배열

// ============================================================
// 🧱 push_loc(): 조건을 만족하는 위치만 스택에 푸시
// ============================================================
// - 유효한 위치인지 체크 (범위 안, 길 또는 출구인지)
// - 조건 만족 시 element 구조체에 좌표 담아 스택에 저장
// ============================================================
void push_loc(StackType *s, int r, int c) {
    if (r < 0 || c < 0 || r >= n || c >= n) return; // 미로 경계 체크
    if (maze[r][c] == '0' || maze[r][c] == 'x') {   // 갈 수 있는 길 또는 출구인지 확인
        element tmp;
        tmp.r = r;
        tmp.c = c;
        push(s, tmp); // 조건 만족 → 스택에 푸시
    }
}

// ============================================================
// 🚀 main(): 프로그램 시작점
// ============================================================
int main(void) {
    StackType s;       // 스택 선언
    element here, entry; // 현재 위치와 시작점 좌표

    scanf("%d", &n);    // 미로 크기 입력
    for (int i = 0; i < n; i++)
        scanf("%s", maze[i]); // 미로 한 줄씩 입력 받기

    // 시작 위치('e') 찾기
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (maze[i][j] == 'e') {
                entry.r = i;
                entry.c = j;
            }

    init_stack(&s);    // 스택 초기화
    here = entry;      // 시작점 설정

    // 출구(x)를 만날 때까지 루프
    while (maze[here.r][here.c] != 'x') {
        int r = here.r;
        int c = here.c;

        // 현재 위치 방문 표시 ('.'), 단 시작점은 표시하지 않음
        if (maze[r][c] != 'e') maze[r][c] = '.';

        // 상하좌우 위치 검사 및 푸시
        push_loc(&s, r - 1, c); // 위
        push_loc(&s, r + 1, c); // 아래
        push_loc(&s, r, c - 1); // 왼쪽
        push_loc(&s, r, c + 1); // 오른쪽

        if (is_empty(&s)) {
            // 더 이상 이동할 경로가 없는 경우
            printf("fail\n");
            return 0;
        } else {
            // 다음 위치 설정
            here = pop(&s);
        }
    }

    // 출구에 도달한 경우
    printf("success\n");
    return 0;
}

/*
===============================================================
🧪 예시 입력:
===============================================================
5
11111
1e001
10101
1000x
11111

🧾 예시 출력:
success

→ 시작점 e에서 출구 x까지 도달 가능한 경우

===============================================================
🧭 실행 흐름 요약
===============================================================

1. 미로 크기 n 입력 → n x n 크기 미로 생성
2. 미로 내용 입력 ('1'=벽, '0'=길, 'e'=시작, 'x'=출구)
3. 시작 위치 'e' 탐색 및 스택 초기화
4. while 루프로 DFS 탐색 시작
   ├─ 현재 위치 방문 처리 ('.')
   ├─ 상하좌우 push_loc() 실행
   ├─ pop()으로 다음 위치 이동
   ├─ 스택이 비면 실패 종료
   └─ 출구 만나면 성공 종료

===============================================================
📚 학습 포인트 요약
===============================================================

- ✅ 스택(Stack) 기반 DFS 탐색 알고리즘
- 🔁 반복문과 조건문으로 미로 내 경로 탐색
- 📦 구조체(struct)를 활용한 좌표 정보 관리
- ✍ 입력: 2차원 문자 배열 입력 처리
- ⚙️ 탐색 과정 시 경로 표시('.')
- 📌 실패 조건(스택이 비면) / 성공 조건(출구 도달) 분기 처리

===============================================================
*/
